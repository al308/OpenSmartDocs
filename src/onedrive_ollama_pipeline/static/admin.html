<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>OneDrive → Ollama Pipeline Admin</title>
        <style>
            :root {
                color-scheme: dark;
            }
            * {
                box-sizing: border-box;
            }
            body {
                font-family: Arial, sans-serif;
                background: #0f172a;
                color: #e2e8f0;
                margin: 0;
            }
            header {
                background: #1e293b;
                padding: 1rem 2rem;
                box-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
            }
            h1 {
                margin: 0;
                font-size: 1.6rem;
            }
            main {
                padding: 2rem;
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
            }
            .tabs {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .tab-button {
                background: #334155;
                border: none;
                color: #e2e8f0;
                padding: 0.6rem 1rem;
                border-radius: 6px;
                cursor: pointer;
                transition: background 0.2s ease;
            }
            .tab-button:hover {
                background: #475569;
            }
            .tab-button.active {
                background: #60a5fa;
                color: #0f172a;
                font-weight: 600;
            }
            .panel {
                display: none;
                background: #1e293b;
                border-radius: 10px;
                padding: 1.75rem;
                box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
            }
            .panel.active {
                display: block;
            }
            .ingest-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 1.5rem;
            }
            .ingest-card {
                background: rgba(148, 163, 184, 0.15);
                padding: 1.75rem;
                border-radius: 10px;
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }
            .ingest-card h2 {
                margin: 0;
                font-size: 1.2rem;
            }
            .dropzone {
                border: 2px dashed rgba(148, 163, 184, 0.35);
                padding: 1.5rem;
                border-radius: 10px;
                text-align: center;
                cursor: pointer;
                transition: border-color 0.2s ease, background 0.2s ease;
            }
            .dropzone.dragover {
                border-color: #38bdf8;
                background: rgba(56, 189, 248, 0.12);
            }
            .dropzone input {
                display: none;
            }
            .ingest-actions {
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
                align-items: center;
            }
            .ingest-status,
            .inbox-status,
            .structure-status,
            .form-status {
                min-height: 1.2rem;
                font-size: 0.9rem;
                color: rgba(226, 232, 240, 0.85);
                margin-top: 0.35rem;
            }
            .ingest-analysis {
                display: none;
                flex-direction: column;
                gap: 0.75rem;
                border-top: 1px solid rgba(148, 163, 184, 0.25);
                padding-top: 1rem;
            }
            .ingest-analysis.visible {
                display: flex;
            }
            .ingest-analysis-summary {
                display: flex;
                flex-direction: column;
                gap: 0.4rem;
                font-size: 0.9rem;
            }
            .ingest-analysis-preview {
                margin: 0;
                padding: 0.75rem;
                background: rgba(15, 23, 42, 0.9);
                border-radius: 6px;
                max-height: 140px;
                overflow-y: auto;
                font-size: 0.85rem;
                white-space: pre-wrap;
                line-height: 1.35;
            }
            .ingest-option-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .ingest-mode-button {
                min-width: 180px;
            }
            button.primary {
                background: #38bdf8;
                color: #0f172a;
                border: none;
                padding: 0.65rem 1.1rem;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
            }
            button.secondary {
                background: #334155;
                color: #e2e8f0;
                border: none;
                padding: 0.55rem 1rem;
                border-radius: 6px;
                cursor: pointer;
            }
            button.primary:disabled,
            button.secondary:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }
            .icon-button {
                background: transparent;
                border: none;
                color: #93c5fd;
                cursor: pointer;
                padding: 0.25rem;
                border-radius: 4px;
                line-height: 1;
                font-size: 1rem;
            }
            .icon-button:hover {
                background: rgba(96, 165, 250, 0.18);
            }
            .icon-button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }
            details.config-details {
                background: rgba(148, 163, 184, 0.12);
                border-radius: 8px;
                padding: 0.75rem 1rem;
                margin-bottom: 1rem;
            }
            details.config-details summary {
                cursor: pointer;
                font-weight: 600;
                color: #93c5fd;
            }
            details.config-details[open] summary {
                margin-bottom: 0.75rem;
            }
            .config-form {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 1rem;
                align-items: flex-end;
            }
            .config-form label {
                display: flex;
                flex-direction: column;
                gap: 0.35rem;
                font-size: 0.9rem;
            }
            .config-form input,
            .config-form select {
                padding: 0.5rem;
                border-radius: 6px;
                border: 1px solid rgba(148, 163, 184, 0.35);
                background: #0f172a;
                color: #e2e8f0;
            }
            .config-form .checkbox-row {
                flex-direction: row;
                align-items: center;
                gap: 0.6rem;
            }
            .config-form .checkbox-row input {
                width: auto;
            }
            .inbox-controls {
                display: flex;
                flex-wrap: wrap;
                justify-content: space-between;
                gap: 1rem;
                align-items: center;
                margin-bottom: 0.75rem;
            }
            .inbox-buttons {
                display: flex;
                gap: 0.5rem;
                flex-wrap: wrap;
            }
            .table-preview-container {
                display: grid;
                grid-template-columns: minmax(0, 1fr) minmax(260px, 28%);
                gap: 1rem;
                align-items: stretch;
            }
            .table-wrapper {
                overflow-x: auto;
                border-radius: 8px;
                border: 1px solid rgba(148, 163, 184, 0.18);
            }
            .preview-panel {
                background: #111c3a;
                border-radius: 8px;
                border: 1px solid rgba(148, 163, 184, 0.18);
                padding: 0.75rem;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                min-height: 320px;
            }
            .preview-panel h3 {
                margin: 0;
                font-size: 1rem;
            }
            .preview-placeholder {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                color: rgba(226, 232, 240, 0.65);
                font-size: 0.9rem;
                padding: 1rem;
                border: 1px dashed rgba(148, 163, 184, 0.25);
                border-radius: 6px;
            }
            .preview-frame {
                flex: 1;
                border: none;
                border-radius: 6px;
                background: #0b1224;
            }
            @media (max-width: 1024px) {
                .table-preview-container {
                    grid-template-columns: 1fr;
                }
                .preview-panel {
                    min-height: 240px;
                }
            }
            table {
                width: 100%;
                border-collapse: collapse;
                min-width: 640px;
            }
            th,
            td {
                text-align: left;
                padding: 0.55rem 0.8rem;
                border-bottom: 1px solid rgba(148, 163, 184, 0.15);
                vertical-align: top;
            }
            th {
                font-size: 0.85rem;
                color: rgba(226, 232, 240, 0.65);
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }
            tr:last-child td {
                border-bottom: none;
            }
            a.link {
                color: #93c5fd;
                text-decoration: none;
            }
            a.link:hover {
                text-decoration: underline;
            }
            .status-chip {
                display: inline-flex;
                align-items: center;
                padding: 0.15rem 0.45rem;
                border-radius: 999px;
                font-size: 0.75rem;
                font-weight: 600;
            }
            .status-chip.pending {
                background: rgba(14, 165, 233, 0.18);
                color: #38bdf8;
            }
            .status-chip.success {
                background: rgba(34, 197, 94, 0.18);
                color: #4ade80;
            }
            .status-chip.failed {
                background: rgba(248, 113, 113, 0.18);
                color: #f87171;
            }
            .structure-summary {
                margin-top: 1rem;
                line-height: 1.55;
            }
            .structure-summary ul {
                padding-left: 1.25rem;
            }
            .structure-summary li {
                margin-bottom: 0.35rem;
            }
            .text-chip {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                min-width: 2.5rem;
                padding: 0.2rem 0.45rem;
                border-radius: 999px;
                font-size: 0.75rem;
                font-weight: 600;
            }
            .text-chip.has-text {
                background: rgba(34, 197, 94, 0.18);
                color: #4ade80;
            }
            .text-chip.no-text {
                background: rgba(148, 163, 184, 0.16);
                color: rgba(226, 232, 240, 0.85);
            }
            .text-chip.pending {
                background: rgba(148, 163, 184, 0.12);
                color: rgba(226, 232, 240, 0.65);
            }
            .text-chip.error {
                background: rgba(248, 113, 113, 0.18);
                color: #f87171;
            }
            .structure-controls {
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                margin-bottom: 1rem;
            }
            .structure-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                align-items: center;
            }
            .structure-summary-details {
                margin-top: 1rem;
                background: rgba(148, 163, 184, 0.12);
                border-radius: 8px;
                padding: 0.75rem 1rem;
            }
            .structure-summary-details summary {
                cursor: pointer;
                font-weight: 600;
                color: #93c5fd;
            }
            .structure-summary-details[open] summary {
                margin-bottom: 0.75rem;
            }
            #structure-sources-table tbody tr.selected {
                background: rgba(96, 165, 250, 0.18);
            }
            #structure-sources-table tbody tr.planned {
                border-left: 3px solid #38bdf8;
            }
            #structure-sources-table td,
            #structure-sources-table th {
                vertical-align: top;
            }
            .structure-log {
                margin-top: 1.5rem;
                background: #0f172a;
                border-radius: 8px;
                border: 1px solid rgba(148, 163, 184, 0.2);
                max-height: 280px;
                overflow-y: auto;
                padding: 1rem;
                font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
                font-size: 0.85rem;
            }
            .structure-log-entry {
                margin-bottom: 0.45rem;
                color: rgba(226, 232, 240, 0.92);
            }
            .structure-log-entry.error {
                color: #f87171;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>OneDrive → Ollama Pipeline Admin</h1>
        </header>
        <main>
            <div class="tabs">
                <button class="tab-button active" data-target="ingest">Ingest</button>
                <button class="tab-button" data-target="inbox">Inbox</button>
                <button class="tab-button" data-target="structure">Structure</button>
            </div>

            <section id="ingest" class="panel active">
                <div class="ingest-grid">
                    <div class="ingest-card">
                        <h2>Regular ingest</h2>
                        <p>Send a single PDF directly to the inbox folder.</p>
                        <div id="ingest-regular-drop" class="dropzone" role="button" tabindex="0">
                            <strong id="ingest-regular-label">Drop PDF here or click to select</strong>
                            <input type="file" id="ingest-regular-input" accept="application/pdf" />
                        </div>
                        <div class="ingest-actions">
                            <button class="primary" id="ingest-regular-upload" disabled>Upload to inbox</button>
                        </div>
                        <div class="ingest-status" id="ingest-regular-status"></div>
                        <div class="ingest-analysis" id="ingest-analysis" hidden>
                            <div class="ingest-analysis-summary">
                                <div id="ingest-analysis-text"></div>
                                <div id="ingest-analysis-meta"></div>
                                <pre class="ingest-analysis-preview" id="ingest-analysis-preview"></pre>
                            </div>
                            <div class="ingest-option-buttons">
                                <button class="secondary ingest-mode-button" id="ingest-mode-text" data-mode="text">Use text &amp; metadata</button>
                                <button class="secondary ingest-mode-button" id="ingest-mode-image" data-mode="image">Use first page image</button>
                                <button class="secondary ingest-mode-button" id="ingest-mode-both" data-mode="both">Use text &amp; image</button>
                            </div>
                            <div class="ingest-status" id="ingest-analysis-status"></div>
                        </div>
                    </div>

                    <div class="ingest-card">
                        <h2>Mass scan (2-sided)</h2>
                        <p>Combine odd and even simplex scans, then deliver the merged PDF to the inbox.</p>
                        <div class="dropzone" id="ingest-odd-drop" role="button" tabindex="0">
                            <strong id="ingest-odd-label">Drop odd pages PDF</strong>
                            <div class="ingest-hint">First pass - front sides.</div>
                            <input type="file" id="ingest-odd-input" accept="application/pdf" />
                        </div>
                        <div class="dropzone" id="ingest-even-drop" role="button" tabindex="0">
                            <strong id="ingest-even-label">Drop even pages PDF</strong>
                            <div class="ingest-hint">Second pass - back sides.</div>
                            <input type="file" id="ingest-even-input" accept="application/pdf" />
                        </div>
                        <form id="ingest-mass-form" class="ingest-form">
                            <label>Final filename (optional)
                                <input type="text" id="ingest-output-name" name="outputName" placeholder="e.g. contract.pdf" />
                            </label>
                            <div class="ingest-actions">
                                <button class="primary" type="submit" id="ingest-mass-submit" disabled>Combine &amp; upload</button>
                            </div>
                            <div class="ingest-status" id="ingest-mass-status"></div>
                        </form>
                    </div>
                </div>
            </section>

            <section id="inbox" class="panel">
                <details class="config-details" id="inbox-config-details">
                    <summary>Inbox configuration</summary>
                    <form id="inbox-config-form" class="config-form">
                        <label>Inbox folder
                            <input type="text" name="inboxFolder" autocomplete="off" />
                        </label>
                        <label>Polling interval (seconds)
                            <input type="number" name="pollIntervalSeconds" min="0" />
                        </label>
                        <label class="checkbox-row">
                            <input type="checkbox" name="autoProcessInbox" /> Auto-process inbox
                        </label>
                        <div>
                            <button class="primary" type="submit">Save changes</button>
                            <div class="form-status" id="inbox-config-status"></div>
                        </div>
                    </form>
                </details>

                <div class="inbox-controls">
                    <div class="inbox-buttons">
                        <button class="secondary" id="inbox-select-all">Select all</button>
                        <button class="secondary" id="inbox-select-pending">Select unprocessed</button>
                        <button class="secondary" id="inbox-toggle-success">Hide processed</button>
                        <button class="primary" id="inbox-process" disabled>Run metadata extraction</button>
                    </div>
                    <div class="inbox-info" id="inbox-counts"></div>
                </div>
                <div class="inbox-status" id="inbox-status"></div>

                <div class="table-preview-container">
                    <div class="table-wrapper">
                        <table id="inbox-table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th></th>
                                    <th>Text</th>
                                    <th>Filename</th>
                                    <th>Status</th>
                                    <th>Processed at</th>
                                    <th>Model</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td colspan="8">Loading inbox…</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <aside class="preview-panel" id="inbox-preview">
                        <h3>Preview</h3>
                        <div class="preview-placeholder">Select a PDF to preview it here.</div>
                    </aside>
                </div>
            </section>

            <section id="structure" class="panel">
                <details class="config-details" id="structure-config-details">
                    <summary>Structure configuration</summary>
                    <form id="structure-config-form" class="config-form">
                        <label>Structure model
                            <input type="text" name="structureModel" autocomplete="off" />
                        </label>
                        <label>Language
                            <select name="structureLanguage">
                                <option value="auto">Automatisch</option>
                                <option value="de">Deutsch</option>
                                <option value="en">English</option>
                            </select>
                        </label>
                        <div>
                            <button class="primary" type="submit">Save changes</button>
                            <div class="form-status" id="structure-config-status"></div>
                        </div>
                    </form>
                </details>

                <p>Use the AI assistant to propose where documents under <code>_sorted</code> should live, including suggested folder structures and renamed copies.</p>
                <div class="structure-controls">
                    <div class="structure-buttons">
                        <button class="secondary" id="structure-select-root">Select all on root level</button>
                        <button class="primary" id="structure-analyze" disabled>Generate proposal</button>
                        <button class="primary" id="structure-execute" disabled>Execute proposed plan</button>
                        <button class="secondary" id="structure-revert" disabled>Revert changes</button>
                    </div>
                    <div class="structure-status" id="structure-status"></div>
                </div>
                <div class="table-preview-container">
                    <div class="table-wrapper">
                        <table id="structure-sources-table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th></th>
                                    <th>Text</th>
                                    <th>File</th>
                                    <th>Current folder</th>
                                    <th>Proposed folder</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td colspan="6">Loading sorted files…</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <aside class="preview-panel" id="structure-preview">
                        <h3>Preview</h3>
                        <div class="preview-placeholder">Select a PDF to preview it here.</div>
                    </aside>
                </div>
                <details class="structure-summary-details" id="structure-summary-panel">
                    <summary>Proposal summary</summary>
                    <div class="structure-summary" id="structure-summary"></div>
                </details>
                <div class="structure-summary" id="structure-applied"></div>
                <div class="structure-log" id="structure-log"></div>
            </section>
        </main>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const tabButtons = Array.from(document.querySelectorAll('.tab-button'));
                const panels = Array.from(document.querySelectorAll('.panel'));
                function activateTab(targetId) {
                    tabButtons.forEach((btn) => btn.classList.toggle('active', btn.dataset.target === targetId));
                    panels.forEach((panel) => panel.classList.toggle('active', panel.id === targetId));
                }
                tabButtons.forEach((button) => {
                    button.addEventListener('click', () => activateTab(button.dataset.target));
                });

                const inboxTableBody = document.querySelector('#inbox-table tbody');
                const inboxSelectAll = document.getElementById('inbox-select-all');
                const inboxSelectPending = document.getElementById('inbox-select-pending');
                const inboxToggleSuccess = document.getElementById('inbox-toggle-success');
                const inboxProcessBtn = document.getElementById('inbox-process');
                const inboxStatus = document.getElementById('inbox-status');
                const inboxCounts = document.getElementById('inbox-counts');
                const inboxConfigForm = document.getElementById('inbox-config-form');
                const inboxConfigStatus = document.getElementById('inbox-config-status');
                const inboxPreviewPanel = document.getElementById('inbox-preview');

                const structureSelectRoot = document.getElementById('structure-select-root');
                const structureAnalyze = document.getElementById('structure-analyze');
                const structureExecute = document.getElementById('structure-execute');
                const structureRevert = document.getElementById('structure-revert');
                const structureStatus = document.getElementById('structure-status');
                const structureSourcesTableBody = document.querySelector('#structure-sources-table tbody');
                const structureSummary = document.getElementById('structure-summary');
                const structureSummaryPanel = document.getElementById('structure-summary-panel');
                const structureApplied = document.getElementById('structure-applied');
                const structureLog = document.getElementById('structure-log');
                const structureConfigForm = document.getElementById('structure-config-form');
                const structureConfigStatus = document.getElementById('structure-config-status');
                const structurePreviewPanel = document.getElementById('structure-preview');

                const DEFAULT_STRUCTURE_POLL_MS = 4000;
                let structurePollTimer = null;
                let structurePollIntervalMs = 0;
                let structurePollInFlight = false;

                const state = {
                    config: null,
                    inboxItems: [],
                    selectedInboxIds: new Set(),
                    showSuccess: true,
                    structureSources: [],
                    selectedStructurePaths: new Set(),
                    structurePlan: null,
                    structureSourcesLoading: false,
                    preview: {
                        inbox: { objectUrl: null, title: '', loading: false, error: '' },
                        structure: { objectUrl: null, title: '', loading: false, error: '' },
                    },
                    textInfo: {
                        inbox: new Map(),
                        structure: new Map(),
                    },
                    processingQueue: [],
                    activeProcessingId: null,
                    processingTimers: new Map(),
                    progressLabels: {
                        download: 'Downloading',
                        convert: 'Converting',
                        metadata: 'Requesting metadata',
                        embed: 'Embedding metadata',
                        upload: 'Uploading copy',
                        done: 'Completed',
                    },
                    progressOrder: ['download', 'convert', 'metadata', 'embed', 'upload'],
                };

                function showStatus(target, message, level = 'info') {
                    if (!target) return;
                    const colors = {
                        info: 'rgba(226, 232, 240, 0.85)',
                        success: '#4ade80',
                        warn: '#facc15',
                        error: '#f87171',
                    };
                    target.style.color = colors[level] || colors.info;
                    target.textContent = message;
                }

                function escapeHtml(value) {
                    if (value === undefined || value === null) {
                        return '';
                    }
                    return String(value)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                }

                function getPreviewContainer(scope) {
                    return scope === 'structure' ? structurePreviewPanel : inboxPreviewPanel;
                }

                function setPreviewState(scope, updates) {
                    const preview = state.preview[scope];
                    if (!preview) {
                        return;
                    }
                    if (Object.prototype.hasOwnProperty.call(updates, 'objectUrl')) {
                        if (preview.objectUrl && preview.objectUrl !== updates.objectUrl) {
                            try {
                                URL.revokeObjectURL(preview.objectUrl);
                            } catch (_err) {
                                /* ignore */
                            }
                        }
                        preview.objectUrl = updates.objectUrl || null;
                    }
                    if (Object.prototype.hasOwnProperty.call(updates, 'title')) {
                        preview.title = updates.title || '';
                    }
                    if (Object.prototype.hasOwnProperty.call(updates, 'loading')) {
                        preview.loading = Boolean(updates.loading);
                    }
                    if (Object.prototype.hasOwnProperty.call(updates, 'error')) {
                        preview.error = updates.error || '';
                    }
                    renderPreviewPanel(scope);
                }

                function renderPreviewPanel(scope) {
                    const container = getPreviewContainer(scope);
                    if (!container) {
                        return;
                    }
                    const preview = state.preview[scope];
                    if (!preview) {
                        return;
                    }
                    let bodyHtml = '<div class="preview-placeholder">Select a PDF to preview it here.</div>';
                    if (preview.loading) {
                        bodyHtml = '<div class="preview-placeholder">Loading preview…</div>';
                    } else if (preview.error) {
                        bodyHtml = `<div class="preview-placeholder">${escapeHtml(preview.error)}</div>`;
                    } else if (preview.objectUrl) {
                        const title = escapeHtml(preview.title || 'PDF preview');
                        bodyHtml = `<iframe class="preview-frame" src="${preview.objectUrl}" title="${title}"></iframe>`;
                    }
                    container.innerHTML = `<h3>Preview</h3>${bodyHtml}`;
                }

                async function openPreview(scope, endpoint, title) {
                    setPreviewState(scope, { loading: true, error: '', title, objectUrl: null });
                    try {
                        const res = await fetch(endpoint);
                        if (!res.ok) {
                            const payload = await res.json().catch(() => ({}));
                            const detail = payload.detail || res.statusText || 'Failed to load preview.';
                            throw new Error(detail);
                        }
                        const blob = await res.blob();
                        const objectUrl = URL.createObjectURL(blob);
                        setPreviewState(scope, { objectUrl, loading: false, error: '', title });
                    } catch (error) {
                        setPreviewState(scope, { loading: false, error: error.message || 'Failed to load preview.', objectUrl: null, title });
                    }
                }

                function renderTextBadge(info) {
                    if (!info || info.status === 'loading' || info.status === undefined) {
                        return '<span class="text-chip pending">…</span>';
                    }
                    if (info.status === 'error') {
                        const message = info.error ? escapeHtml(info.error) : 'Unavailable';
                        return `<span class="text-chip error" title="${message}">Err</span>`;
                    }
                    return info.value ? '<span class="text-chip has-text">Yes</span>' : '<span class="text-chip no-text">No</span>';
                }

                function ensureTextInfo(scope, key, endpoint) {
                    if (!key || !endpoint) {
                        return;
                    }
                    const bucket = state.textInfo[scope];
                    if (!(bucket instanceof Map)) {
                        return;
                    }
                    const existing = bucket.get(key);
                    if (existing && existing.status !== 'error') {
                        return;
                    }
                    if (existing && existing.status === 'error') {
                        return;
                    }
                    bucket.set(key, { status: 'loading' });
                    fetch(endpoint)
                        .then(async (res) => {
                            if (!res.ok) {
                                const payload = await res.json().catch(() => ({}));
                                const detail = payload.detail || res.statusText || 'Failed to inspect text content.';
                                throw new Error(detail);
                            }
                            return res.json();
                        })
                        .then((payload) => {
                            const hasText = Boolean(payload && payload.hasText);
                            bucket.set(key, { status: 'ready', value: hasText });
                            if (scope === 'inbox') {
                                renderInboxTable();
                            } else {
                                renderStructureSourcesTable();
                            }
                        })
                        .catch((error) => {
                            bucket.set(key, { status: 'error', error: error.message || 'Failed to inspect text content.' });
                            if (scope === 'inbox') {
                                renderInboxTable();
                            } else {
                                renderStructureSourcesTable();
                            }
                        });
                }

                async function fetchConfig() {
                    const res = await fetch('/api/config');
                    if (!res.ok) {
                        throw new Error('Failed to load configuration');
                    }
                    state.config = await res.json();
                }

                function populateConfigForms() {
                    if (!state.config) {
                        return;
                    }
                    if (inboxConfigForm) {
                        inboxConfigForm.inboxFolder.value = state.config.inbox_folder || '';
                        inboxConfigForm.pollIntervalSeconds.value = state.config.poll_interval_seconds ?? '';
                        inboxConfigForm.autoProcessInbox.checked = Boolean(state.config.auto_process_inbox);
                    }
                    if (structureConfigForm) {
                        structureConfigForm.structureModel.value = state.config.structure_model || '';
                        if (structureConfigForm.structureLanguage) {
                            structureConfigForm.structureLanguage.value = state.config.structure_language || 'auto';
                        }
                    }
                }

                async function updateConfig(payload, statusElement) {
                    try {
                        const res = await fetch('/api/config', {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        const data = await res.json().catch(() => ({}));
                        if (!res.ok) {
                            throw new Error(data.detail || 'Failed to update configuration');
                        }
                        state.config = data;
                        populateConfigForms();
                        showStatus(statusElement, 'Configuration saved.', 'success');
                    } catch (error) {
                        showStatus(statusElement, error.message || 'Failed to update configuration.', 'error');
                    }
                }

                if (inboxConfigForm) {
                    inboxConfigForm.addEventListener('submit', async (event) => {
                        event.preventDefault();
                        const payload = {};
                        const inboxFolder = inboxConfigForm.inboxFolder.value.trim();
                        if (inboxFolder) {
                            payload.inboxFolder = inboxFolder;
                        }
                        const pollValue = inboxConfigForm.pollIntervalSeconds.value;
                        if (pollValue !== '') {
                            payload.pollIntervalSeconds = Number(pollValue);
                        }
                        payload.autoProcessInbox = inboxConfigForm.autoProcessInbox.checked;
                        await updateConfig(payload, inboxConfigStatus);
                        await loadInbox();
                    });
                }

                if (structureConfigForm) {
                    structureConfigForm.addEventListener('submit', async (event) => {
                        event.preventDefault();
                        const structureModel = structureConfigForm.structureModel.value.trim();
                        const structureLanguage = structureConfigForm.structureLanguage ? structureConfigForm.structureLanguage.value : 'auto';
                        await updateConfig({ structureModel, structureLanguage }, structureConfigStatus);
                    });
                }

                function updateInboxProcessButton() {
                    inboxProcessBtn.disabled = state.selectedInboxIds.size === 0;
                }

                function renderInboxTable() {
                    if (!inboxTableBody) {
                        return;
                    }
                    const visibleItems = state.showSuccess ? state.inboxItems : state.inboxItems.filter((item) => item.status !== 'success');
                    if (!visibleItems.length) {
                        inboxTableBody.innerHTML = '<tr><td colspan="8">Inbox is empty.</td></tr>';
                        updateInboxProcessButton();
                        return;
                    }
                    const rows = visibleItems
                        .map((item) => {
                            const checked = state.selectedInboxIds.has(item.id) ? 'checked' : '';
                            const statusClass = `status-chip ${item.status}`;
                            const processedAt = item.processed_at ? new Date(item.processed_at).toLocaleString() : '—';
                            const notes = item.status === 'failed'
                                ? (item.error_message || item.transient_note || 'Processing failed.')
                                : item.transient_note || item.metadata_preview || '';
                            const link = item.web_url ? `<a class="link" href="${item.web_url}" target="_blank" rel="noopener">${item.name}</a>` : item.name;
                            const previewButton = `<button type="button" class="icon-button preview-btn" data-preview-id="${item.id}" data-preview-name="${escapeHtml(item.name || '')}" title="Preview PDF">👁️</button>`;
                            const textInfo = state.textInfo.inbox.get(item.id);
                            ensureTextInfo('inbox', item.id, `/api/inbox/text-info/${encodeURIComponent(item.id)}`);
                            const textCell = renderTextBadge(textInfo);
                            return `
                                <tr data-item-id="${item.id}">
                                    <td>${previewButton}</td>
                                    <td><input type="checkbox" value="${item.id}" ${checked} /></td>
                                    <td>${textCell}</td>
                                    <td>${link}</td>
                                    <td><span class="${statusClass}">${item.status}</span></td>
                                    <td>${processedAt}</td>
                                    <td>${item.model || '—'}</td>
                                    <td>${notes || '—'}</td>
                                </tr>
                            `;
                        })
                        .join('');
                    inboxTableBody.innerHTML = rows;
                    inboxTableBody.querySelectorAll('input[type="checkbox"]').forEach((checkbox) => {
                        checkbox.addEventListener('change', () => {
                            if (checkbox.checked) {
                                state.selectedInboxIds.add(checkbox.value);
                            } else {
                                state.selectedInboxIds.delete(checkbox.value);
                            }
                            updateInboxProcessButton();
                        });
                    });
                    inboxTableBody.querySelectorAll('.preview-btn').forEach((button) => {
                        button.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            const id = button.dataset.previewId;
                            const item = state.inboxItems.find((entry) => entry.id === id);
                            const title = button.dataset.previewName || (item ? item.name : 'Inbox file');
                            if (!item) {
                                setPreviewState('inbox', { loading: false, error: 'File unavailable.', objectUrl: null, title });
                                return;
                            }
                            openPreview('inbox', `/api/inbox/preview/${encodeURIComponent(id)}`, title || 'Inbox file');
                        });
                    });
                    updateInboxProcessButton();
                }

                function updateInboxCounts(counts) {
                    if (!inboxCounts) {
                        return;
                    }
                    if (!counts) {
                        inboxCounts.textContent = '';
                        return;
                    }
                    inboxCounts.textContent = `Total: ${counts.total} · Pending: ${counts.pending} · Processed: ${counts.processed} · Failed: ${counts.failed}`;
                    if (!state.showSuccess) {
                        inboxCounts.textContent += ' (processed hidden)';
                    }
                }

                async function loadInbox() {
                    try {
                        const res = await fetch('/api/inbox');
                        const data = await res.json().catch(() => ({}));
                        if (!res.ok) {
                            throw new Error(data.detail || 'Failed to load inbox');
                        }
                        if (data.config) {
                            state.config = {
                                ...(state.config || {}),
                                inbox_folder: data.config.inboxFolder,
                                poll_interval_seconds: data.config.pollIntervalSeconds,
                                auto_process_inbox: data.config.autoProcessInbox,
                                structure_language: data.config.structureLanguage || (state.config ? state.config.structure_language : 'auto'),
                                structure_model: data.config.structureModel || (state.config ? state.config.structure_model : ''),
                            };
                            populateConfigForms();
                        }
                        const items = (data.items || []).map((item) => ({ ...item, transient_note: '' }));
                        state.inboxItems = items;
                        const presentIds = new Set(items.map((item) => item.id));
                        const inboxTextMap = state.textInfo.inbox;
                        if (inboxTextMap instanceof Map) {
                            Array.from(inboxTextMap.keys()).forEach((id) => {
                                if (!presentIds.has(id)) {
                                    inboxTextMap.delete(id);
                                }
                            });
                        }
                        state.processingQueue = state.processingQueue.filter((id) => presentIds.has(id));
                        state.processingTimers.forEach((entry, id) => {
                            if (!items.find((item) => item.id === id && item.status === 'processing')) {
                                clearInterval(entry.timer);
                                state.processingTimers.delete(id);
                            }
                        });
                        if (state.activeProcessingId && !presentIds.has(state.activeProcessingId)) {
                            state.activeProcessingId = null;
                        }
                        if (state.activeProcessingId) {
                            const activeItem = items.find((item) => item.id === state.activeProcessingId);
                            if (activeItem) {
                                activeItem.status = 'processing';
                                activeItem.transient_note = activeItem.transient_note || 'Processing…';
                            }
                        }
                        state.processingQueue.forEach((id) => {
                            if (id !== state.activeProcessingId) {
                                const queuedItem = items.find((item) => item.id === id);
                                if (queuedItem && queuedItem.status !== 'success' && queuedItem.status !== 'failed') {
                                    queuedItem.status = 'pending';
                                    queuedItem.transient_note = 'Queued for processing';
                                }
                            }
                        });
                        state.selectedInboxIds.forEach((id) => {
                            if (!state.inboxItems.find((item) => item.id === id && (state.showSuccess || item.status !== 'success'))) {
                                state.selectedInboxIds.delete(id);
                            }
                        });
                        renderInboxTable();
                        updateInboxCounts(data.counts);
                        startProcessingLoop();
                    } catch (error) {
                        renderInboxTable();
                        showStatus(inboxStatus, error.message || 'Failed to load inbox.', 'error');
                    }
                }

                async function processSelectedInbox() {
                    const ids = Array.from(state.selectedInboxIds);
                    if (!ids.length) {
                        return;
                    }
                    inboxProcessBtn.disabled = true;
                    showStatus(inboxStatus, 'Processing selected files…', 'info');
                    startProcessingIndicators(ids);
                    renderInboxTable();
                    try {
                        const res = await fetch('/api/inbox/process', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ itemIds: ids }),
                        });
                        const payload = await res.json().catch(() => ({}));
                        if (!res.ok) {
                            throw new Error(payload.detail || 'Metadata extraction failed.');
                        }
                        const processed = payload.processed || 0;
                        const failed = payload.failed || 0;
                        const level = failed ? 'warn' : 'success';
                        if (Array.isArray(payload.results)) {
                            payload.results.forEach(updateProcessingResult);
                            renderInboxTable();
                        }
                        showStatus(inboxStatus, `Processed ${processed} file(s), ${failed} failed.`, level);
                    } catch (error) {
                        showStatus(inboxStatus, error.message || 'Metadata extraction failed.', 'error');
                    } finally {
                        state.selectedInboxIds.clear();
                        await loadInbox();
                    }
                }

                if (inboxSelectAll) {
                    inboxSelectAll.addEventListener('click', () => {
                        state.selectedInboxIds = new Set(state.inboxItems.map((item) => item.id));
                        renderInboxTable();
                    });
                }

                if (inboxSelectPending) {
                    inboxSelectPending.addEventListener('click', () => {
                        state.selectedInboxIds = new Set(state.inboxItems.filter((item) => item.status !== 'success').map((item) => item.id));
                        renderInboxTable();
                    });
                }

                if (inboxToggleSuccess) {
                    inboxToggleSuccess.addEventListener('click', () => {
                        state.showSuccess = !state.showSuccess;
                        inboxToggleSuccess.textContent = state.showSuccess ? 'Hide processed' : 'Show processed';
                        if (!state.showSuccess) {
                            state.selectedInboxIds = new Set(Array.from(state.selectedInboxIds).filter((id) => {
                                return state.inboxItems.some((item) => item.id === id && item.status !== 'success');
                            }));
                        }
                        renderInboxTable();
                    });
                }

                if (inboxProcessBtn) {
                    inboxProcessBtn.addEventListener('click', processSelectedInbox);
                }

                function normalizeFolderLabel(folder) {
                    const value = (folder || '').trim();
                    return value ? value : '/';
                }

                function renderStructureSourcesTable() {
                    if (!structureSourcesTableBody) {
                        return;
                    }
                    if (state.structureSourcesLoading) {
                        structureSourcesTableBody.innerHTML = '<tr><td colspan="6">Loading sorted files…</td></tr>';
                        if (structureSelectRoot) {
                            structureSelectRoot.disabled = true;
                        }
                        if (structureAnalyze) {
                            structureAnalyze.disabled = true;
                        }
                        return;
                    }
                    if (!Array.isArray(state.structureSources) || state.structureSources.length === 0) {
                        structureSourcesTableBody.innerHTML = '<tr><td colspan="6">No root-level files found. Use the select button after placing files in the sorted root.</td></tr>';
                        if (structureSelectRoot) {
                            structureSelectRoot.disabled = true;
                        }
                        if (structureAnalyze) {
                            structureAnalyze.disabled = true;
                        }
                        return;
                    }
                    if (structureSelectRoot) {
                        structureSelectRoot.disabled = false;
                    }

                    const plan = state.structurePlan;
                    const planSources = plan && plan.context && Array.isArray(plan.context.sources) ? plan.context.sources : [];
                    const planSourceByPath = new Map();
                    planSources.forEach((src) => {
                        if (src && src.relative_path) {
                            planSourceByPath.set(src.relative_path, src);
                        }
                    });
                    const proposalBySourceId = new Map();
                    if (plan && Array.isArray(plan.operations)) {
                        plan.operations.forEach((op) => {
                            if (op && op.action === 'copy_file' && op.source_id) {
                                proposalBySourceId.set(op.source_id, {
                                    folder: op.target_folder || '',
                                    name: op.target_name || '',
                                });
                            }
                        });
                    }

                    const rows = state.structureSources.map((source) => {
                        const relpath = source.relativePath;
                        const selected = state.selectedStructurePaths.has(relpath);
                        const planSource = planSourceByPath.get(relpath);
                        const proposal = planSource ? proposalBySourceId.get(planSource.id) : null;
                        const hintFolder = planSource && planSource.hints ? planSource.hints.suggested_folder : '';
                        const proposedFolder = proposal && proposal.folder ? proposal.folder : hintFolder || '';
                        const proposedName = proposal && proposal.name ? proposal.name : planSource && planSource.hints ? planSource.hints.suggested_target_name : '';
                        const classes = [];
                        if (selected) {
                            classes.push('selected');
                        }
                        if (proposal) {
                            classes.push('planned');
                        }
                        const titleAttr = proposedName ? ` title="${escapeHtml(proposedName)}"` : '';
                        const previewButton = `<button type="button" class="icon-button preview-btn" data-preview-path="${escapeHtml(relpath)}" data-preview-name="${escapeHtml(source.name)}" title="Preview PDF">👁️</button>`;
                        const textInfo = state.textInfo.structure.get(relpath);
                        ensureTextInfo('structure', relpath, `/api/structure/text-info?relative_path=${encodeURIComponent(relpath)}`);
                        const textCell = renderTextBadge(textInfo);
                        return `
                            <tr data-relpath="${escapeHtml(relpath)}" class="${classes.join(' ')}">
                                <td>${previewButton}</td>
                                <td><input type="checkbox" data-relpath="${escapeHtml(relpath)}" ${selected ? 'checked' : ''} /></td>
                                <td>${textCell}</td>
                                <td>${escapeHtml(source.name)}</td>
                                <td>${escapeHtml(normalizeFolderLabel(source.folder))}</td>
                                <td${titleAttr}>${escapeHtml(proposedFolder ? proposedFolder : '—')}</td>
                            </tr>
                        `;
                    });

                    structureSourcesTableBody.innerHTML = rows.join('');
                    if (structureAnalyze) {
                        structureAnalyze.disabled = state.selectedStructurePaths.size === 0;
                    }
                    structureSourcesTableBody.querySelectorAll('.preview-btn').forEach((button) => {
                        button.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            const relpath = button.dataset.previewPath;
                            if (!relpath) {
                                setPreviewState('structure', { loading: false, error: 'Unable to preview selection.', objectUrl: null });
                                return;
                            }
                            const source = state.structureSources.find((entry) => entry.relativePath === relpath);
                            const title = (button.dataset.previewName || (source ? source.name : 'Document')) || 'Document';
                            openPreview('structure', `/api/structure/preview?relative_path=${encodeURIComponent(relpath)}`, title);
                        });
                    });
                }

                async function loadStructureSources() {
                    if (!structureSourcesTableBody) {
                        return;
                    }
                    state.structureSourcesLoading = true;
                    renderStructureSourcesTable();
                    try {
                        const res = await fetch('/api/structure/sources?limit=200');
                        if (!res.ok) {
                            throw new Error('Failed to load sorted files');
                        }
                        const payload = await res.json();
                        const sources = Array.isArray(payload.sources) ? payload.sources : [];
                        const previousSelection = new Set(state.selectedStructurePaths);
                        state.structureSources = sources
                            .map((item) => ({
                                relativePath: String(item.relative_path || item.name || '').trim(),
                                name: String(item.name || item.relative_path || '').trim(),
                                folder: String(item.folder || '').trim(),
                            }))
                            .filter((item) => item.relativePath);

                        if (state.structureSources.length === 0) {
                            state.selectedStructurePaths = new Set();
                        } else if (previousSelection.size) {
                            const retained = state.structureSources
                                .map((item) => item.relativePath)
                                .filter((path) => previousSelection.has(path));
                            state.selectedStructurePaths = new Set(retained);
                        } else {
                            state.selectedStructurePaths = new Set();
                        }
                        const availablePaths = new Set(state.structureSources.map((item) => item.relativePath));
                        const structureTextMap = state.textInfo.structure;
                        if (structureTextMap instanceof Map) {
                            Array.from(structureTextMap.keys()).forEach((path) => {
                                if (!availablePaths.has(path)) {
                                    structureTextMap.delete(path);
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Failed to load structure sources', error);
                        state.structureSources = [];
                        state.selectedStructurePaths = new Set();
                        state.textInfo.structure = new Map();
                    } finally {
                        state.structureSourcesLoading = false;
                        renderStructureSourcesTable();
                    }
                }

                function renderStructurePlan(plan) {
                    if (!structureSummary) {
                        return;
                    }
                    state.structurePlan = plan;
                    if (structureSummaryPanel) {
                        structureSummaryPanel.open = false;
                    }
                    if (!plan) {
                        structureSummary.innerHTML = '<p>No plan has been generated yet.</p>';
                        if (structureExecute) {
                            structureExecute.disabled = true;
                        }
                        renderStructureSourcesTable();
                        return;
                    }
                    const operations = Array.isArray(plan.operations) ? plan.operations : [];
                    const generatedAt = plan.generated_at ? new Date(plan.generated_at).toLocaleString() : 'recently';
                    const fragments = [
                        `<h3>Plan generated ${generatedAt}</h3>`,
                        `<p>Total operations proposed: <strong>${operations.length}</strong></p>`,
                    ];
                    if (plan.summary) {
                        fragments.push(`<p>${plan.summary}</p>`);
                    }
                    if (plan.validation && plan.validation.status) {
                        const status = String(plan.validation.status || '').toUpperCase();
                        const notes = plan.validation.notes ? `<br><em>${plan.validation.notes}</em>` : '';
                        fragments.push(`<p><strong>Sanity check:</strong> ${status}${notes}</p>`);
                        if (Array.isArray(plan.validation.issues) && plan.validation.issues.length) {
                            const issues = plan.validation.issues.map((issue) => `<li>${issue}</li>`).join('');
                            fragments.push(`<details><summary>Validation issues</summary><ul>${issues}</ul></details>`);
                        }
                    }
                    if (operations.length) {
                        const items = operations
                            .map((op) => {
                                if (op.action === 'create_folder') {
                                    const note = op.justification ? ` <em>${op.justification}</em>` : '';
                                    return `<li><strong>Create folder</strong> → ${op.path}${note}</li>`;
                                }
                                if (op.action === 'copy_file') {
                                    const folder = op.target_folder ? `${op.target_folder}/` : '';
                                    const note = op.justification ? ` <em>${op.justification}</em>` : '';
                                    return `<li><strong>Copy</strong> ${op.source_id} → ${folder}${op.target_name}${note}</li>`;
                                }
                                return '';
                            })
                            .filter(Boolean)
                            .join('');
                        fragments.push(`<ul>${items}</ul>`);
                    } else {
                        fragments.push('<p>No actions proposed.</p>');
                    }
                    structureSummary.innerHTML = fragments.join('');
                    if (structureExecute) {
                        structureExecute.disabled = operations.length === 0;
                    }
                    renderStructureSourcesTable();
                }

                function renderStructureApplied(applied) {
                    if (!structureApplied) {
                        return;
                    }
                    if (!applied) {
                        structureApplied.innerHTML = '';
                        structureRevert.disabled = true;
                        return;
                    }
                    const createdFiles = Array.isArray(applied.created_files) ? applied.created_files.length : 0;
                    const createdFolders = Array.isArray(applied.created_folders) ? applied.created_folders.length : 0;
                    const appliedAt = applied.applied_at ? new Date(applied.applied_at).toLocaleString() : '';
                    structureApplied.innerHTML = `
                        <h3>Last applied changes</h3>
                        ${appliedAt ? `<p>Applied at ${appliedAt}</p>` : ''}
                        <p>Created files: ${createdFiles}, folders: ${createdFolders}.</p>
                    `;
                    structureRevert.disabled = createdFiles === 0 && createdFolders === 0;
                }

                function renderStructureLog(entries) {
                    if (!structureLog) {
                        return;
                    }
                    if (!Array.isArray(entries) || !entries.length) {
                        structureLog.innerHTML = '<p>No structure activity yet.</p>';
                        return;
                    }
                    structureLog.innerHTML = entries
                        .map((entry) => {
                            const level = entry.level === 'error' ? ' error' : '';
                            const timestamp = entry.timestamp ? new Date(entry.timestamp).toLocaleString() : '';
                            return `<div class="structure-log-entry${level}">[${timestamp}] ${entry.message}</div>`;
                        })
                        .join('');
                }

                async function loadStructureState() {
                    try {
                        const res = await fetch('/api/structure');
                        if (!res.ok) {
                            throw new Error('Failed to load structure state');
                        }
                        const data = await res.json();
                        renderStructurePlan(data.plan || null);
                        renderStructureApplied(data.applied || null);
                        renderStructureLog(data.log || []);
                        if (!structureStatus.textContent) {
                            structureStatus.style.color = 'rgba(226, 232, 240, 0.85)';
                        }
                    } catch (error) {
                        showStatus(structureStatus, error.message || 'Failed to load structure state.', 'error');
                    }
                }

                function pollStructureState() {
                    if (structurePollInFlight) {
                        return;
                    }
                    structurePollInFlight = true;
                    loadStructureState()
                        .catch(() => {})
                        .finally(() => {
                            structurePollInFlight = false;
                        });
                }

                function setStructurePolling(intervalMs) {
                    if (structurePollTimer) {
                        clearInterval(structurePollTimer);
                        structurePollTimer = null;
                    }
                    structurePollIntervalMs = intervalMs || 0;
                    if (intervalMs && intervalMs > 0) {
                        structurePollTimer = setInterval(pollStructureState, intervalMs);
                    }
                }

                if (structureAnalyze) {
                    structureAnalyze.addEventListener('click', async () => {
                        if (structureAnalyze.disabled) {
                            return;
                        }
                        const selected = Array.from(state.selectedStructurePaths);
                        if (!selected.length) {
                            showStatus(structureStatus, 'Select at least one root-level file first.', 'warn');
                            return;
                        }
                        const previousInterval = structurePollIntervalMs || DEFAULT_STRUCTURE_POLL_MS;
                        setStructurePolling(2000);
                        pollStructureState();
                        structureAnalyze.disabled = true;
                        showStatus(structureStatus, 'Generating proposal...', 'info');
                        try {
                            const res = await fetch('/api/structure/analyze', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ relativePaths: selected }),
                            });
                            const payload = await res.json().catch(() => ({}));
                            if (!res.ok) {
                                throw new Error(payload.detail || 'Failed to generate proposal.');
                            }
                            renderStructurePlan(payload);
                            showStatus(structureStatus, 'Proposal ready. Review before executing.', 'success');
                        } catch (error) {
                            showStatus(structureStatus, error.message || 'Failed to generate proposal.', 'error');
                        } finally {
                            await loadStructureState();
                            setStructurePolling(previousInterval || DEFAULT_STRUCTURE_POLL_MS);
                            renderStructureSourcesTable();
                        }
                    });
                }

                if (structureExecute) {
                    structureExecute.addEventListener('click', async () => {
                        if (structureExecute.disabled) {
                            return;
                        }
                        const previousInterval = structurePollIntervalMs || DEFAULT_STRUCTURE_POLL_MS;
                        setStructurePolling(2000);
                        pollStructureState();
                        structureExecute.disabled = true;
                        showStatus(structureStatus, 'Executing proposed plan...', 'info');
                        try {
                            const res = await fetch('/api/structure/apply', { method: 'POST' });
                            const payload = await res.json().catch(() => ({}));
                            if (!res.ok) {
                                throw new Error(payload.detail || 'Failed to execute plan.');
                            }
                            showStatus(structureStatus, 'Structure plan executed.', 'success');
                        } catch (error) {
                            showStatus(structureStatus, error.message || 'Failed to execute plan.', 'error');
                        } finally {
                            await loadStructureState();
                            await loadStructureSources();
                            setStructurePolling(previousInterval || DEFAULT_STRUCTURE_POLL_MS);
                        }
                    });
                }

                if (structureRevert) {
                    structureRevert.addEventListener('click', async () => {
                        if (structureRevert.disabled) {
                            return;
                        }
                        if (!confirm('Remove the folders and copies created by the structure assistant?')) {
                            return;
                        }
                        const previousInterval = structurePollIntervalMs || DEFAULT_STRUCTURE_POLL_MS;
                        setStructurePolling(2000);
                        pollStructureState();
                        structureRevert.disabled = true;
                        showStatus(structureStatus, 'Reverting applied changes...', 'info');
                        try {
                            const res = await fetch('/api/structure/revert', { method: 'POST' });
                            const payload = await res.json().catch(() => ({}));
                            if (!res.ok) {
                                throw new Error(payload.detail || 'Failed to revert changes.');
                            }
                            showStatus(structureStatus, 'Applied changes have been reverted.', 'success');
                        } catch (error) {
                            showStatus(structureStatus, error.message || 'Failed to revert changes.', 'error');
                        } finally {
                            await loadStructureState();
                            await loadStructureSources();
                            setStructurePolling(previousInterval || DEFAULT_STRUCTURE_POLL_MS);
                            structureRevert.disabled = false;
                        }
                    });
                }

                if (structureSelectRoot) {
                    structureSelectRoot.addEventListener('click', () => {
                        if (!Array.isArray(state.structureSources) || !state.structureSources.length) {
                            return;
                        }
                        const rootPaths = state.structureSources
                            .filter((item) => !item.folder)
                            .map((item) => item.relativePath);
                        const fallback = rootPaths.length ? rootPaths : state.structureSources.map((item) => item.relativePath);
                        state.selectedStructurePaths = new Set(fallback);
                        renderStructureSourcesTable();
                    });
                }

                if (structureSourcesTableBody) {
                    structureSourcesTableBody.addEventListener('change', (event) => {
                        const checkbox = event.target;
                        if (checkbox && checkbox.matches('input[type="checkbox"][data-relpath]')) {
                            const relpath = checkbox.dataset.relpath;
                            if (!relpath) {
                                return;
                            }
                            if (checkbox.checked) {
                                state.selectedStructurePaths.add(relpath);
                            } else {
                                state.selectedStructurePaths.delete(relpath);
                            }
                            renderStructureSourcesTable();
                        }
                    });
                    structureSourcesTableBody.addEventListener('click', (event) => {
                        if (event.target.closest('.preview-btn')) {
                            return;
                        }
                        const row = event.target.closest('tr[data-relpath]');
                        if (!row) {
                            return;
                        }
                        if (event.target.matches('input[type="checkbox"]')) {
                            return;
                        }
                        const relpath = row.dataset.relpath;
                        if (!relpath) {
                            return;
                        }
                        if (state.selectedStructurePaths.has(relpath)) {
                            state.selectedStructurePaths.delete(relpath);
                        } else {
                            state.selectedStructurePaths.add(relpath);
                        }
                        renderStructureSourcesTable();
                    });
                }

                renderPreviewPanel('inbox');
                renderPreviewPanel('structure');

                window.addEventListener('beforeunload', () => {
                    ['inbox', 'structure'].forEach((scope) => {
                        const preview = state.preview[scope];
                        if (preview && preview.objectUrl) {
                            try {
                                URL.revokeObjectURL(preview.objectUrl);
                            } catch (_err) {
                                /* ignore */
                            }
                        }
                    });
                });

                const regularInput = document.getElementById('ingest-regular-input');
                const regularDrop = document.getElementById('ingest-regular-drop');
                const regularLabel = document.getElementById('ingest-regular-label');
                const regularUpload = document.getElementById('ingest-regular-upload');
                const regularStatus = document.getElementById('ingest-regular-status');
                const oddInput = document.getElementById('ingest-odd-input');
                const evenInput = document.getElementById('ingest-even-input');
                const oddDrop = document.getElementById('ingest-odd-drop');
                const evenDrop = document.getElementById('ingest-even-drop');
                const oddLabel = document.getElementById('ingest-odd-label');
                const evenLabel = document.getElementById('ingest-even-label');
                const massForm = document.getElementById('ingest-mass-form');
                const massSubmit = document.getElementById('ingest-mass-submit');
                const massStatus = document.getElementById('ingest-mass-status');
                const outputNameInput = document.getElementById('ingest-output-name');
                const ingestAnalysisPanel = document.getElementById('ingest-analysis');
                const ingestAnalysisText = document.getElementById('ingest-analysis-text');
                const ingestAnalysisMeta = document.getElementById('ingest-analysis-meta');
                const ingestAnalysisPreview = document.getElementById('ingest-analysis-preview');
                const ingestAnalysisStatus = document.getElementById('ingest-analysis-status');
                const ingestModeButtons = Array.from(document.querySelectorAll('.ingest-mode-button'));
                const ingestModeText = document.getElementById('ingest-mode-text');
                const ingestModeImage = document.getElementById('ingest-mode-image');
                const ingestModeBoth = document.getElementById('ingest-mode-both');

                const regularDefaultLabel = regularLabel ? regularLabel.textContent : 'Drop PDF here or click to select';
                const oddDefaultLabel = oddLabel ? oddLabel.textContent : 'Drop odd pages PDF';
                const evenDefaultLabel = evenLabel ? evenLabel.textContent : 'Drop even pages PDF';

                let regularFile = null;
                let oddFile = null;
                let evenFile = null;
                let currentIngestItem = null;
                let ingestSelectedMode = null;

                function isPdfFile(file) {
                    return file && file.type === 'application/pdf';
                }

                function showIngestStatus(target, message, level = 'info') {
                    showStatus(target, message, level);
                }

                function resetIngestAnalysis() {
                    currentIngestItem = null;
                    ingestSelectedMode = null;
                    if (ingestAnalysisPanel) {
                        ingestAnalysisPanel.hidden = true;
                        ingestAnalysisPanel.classList.remove('visible');
                    }
                    if (ingestAnalysisStatus) {
                        ingestAnalysisStatus.textContent = '';
                    }
                    if (ingestAnalysisText) ingestAnalysisText.textContent = '';
                    if (ingestAnalysisMeta) ingestAnalysisMeta.textContent = '';
                    if (ingestAnalysisPreview) {
                        ingestAnalysisPreview.textContent = '';
                        ingestAnalysisPreview.hidden = true;
                    }
                    ingestModeButtons.forEach((btn) => {
                        btn.classList.remove('primary');
                        btn.classList.add('secondary');
                    });
                }

                function setIngestModeHighlight(mode) {
                    ingestSelectedMode = mode;
                    ingestModeButtons.forEach((btn) => {
                        const isActive = Boolean(mode && btn.dataset.mode === mode && !btn.disabled);
                        btn.classList.toggle('primary', isActive);
                        btn.classList.toggle('secondary', !isActive);
                    });
                }

                function renderIngestAnalysis(result) {
                    if (!ingestAnalysisPanel) {
                        return;
                    }
                    if (!result) {
                        resetIngestAnalysis();
                        return;
                    }
                    currentIngestItem = result;
                    const analysis = result.analysis || {};
                    const textInfo = analysis.text || {};
                    const metadataInfo = analysis.metadata || {};
                    ingestAnalysisPanel.hidden = false;
                    ingestAnalysisPanel.classList.add('visible');
                    if (ingestAnalysisText) {
                        ingestAnalysisText.textContent = textInfo.available
                            ? `Readable text detected (${textInfo.chars} characters).`
                            : 'No readable text detected.';
                    }
                    if (ingestAnalysisMeta) {
                        const metaEntries = Object.entries(metadataInfo.fields || {});
                        ingestAnalysisMeta.textContent = metadataInfo.available && metaEntries.length
                            ? `Embedded metadata: ${metaEntries.slice(0, 4).map(([k, v]) => `${k}: ${v}`).join(' • ')}`
                            : 'No embedded PDF metadata found.';
                    }
                    if (ingestAnalysisPreview) {
                        if (textInfo.preview) {
                            ingestAnalysisPreview.hidden = false;
                            ingestAnalysisPreview.textContent = textInfo.preview;
                        } else {
                            ingestAnalysisPreview.hidden = true;
                            ingestAnalysisPreview.textContent = '';
                        }
                    }
                    const textAvailable = Boolean(textInfo.available);
                    const hasItemReference = Boolean(result.item && result.item.itemId);
                    if (ingestModeText) ingestModeText.disabled = !textAvailable || !hasItemReference;
                    if (ingestModeBoth) ingestModeBoth.disabled = !textAvailable || !hasItemReference;
                    if (ingestModeImage) ingestModeImage.disabled = !hasItemReference;
                    let recommended = result.recommendedStrategy || (textAvailable ? 'text' : 'image');
                    if ((recommended === 'text' || recommended === 'both') && !textAvailable) {
                        recommended = 'image';
                    }
                    if (!hasItemReference) {
                        setIngestModeHighlight(null);
                        showIngestStatus(ingestAnalysisStatus, 'Processing options unavailable (missing item reference).', 'error');
                        return;
                    }
                    setIngestModeHighlight(recommended);
                    showIngestStatus(ingestAnalysisStatus, 'Choose how to generate metadata.', 'info');
                }

                async function processIngestMode(mode) {
                    if (!currentIngestItem || !currentIngestItem.item) {
                        showIngestStatus(ingestAnalysisStatus, 'Upload a PDF first.', 'error');
                        return;
                    }
                    const item = currentIngestItem.item;
                    if (!item.itemId) {
                        showIngestStatus(ingestAnalysisStatus, 'Cannot process this upload (missing item id).', 'error');
                        return;
                    }
                    const payload = {
                        itemId: item.itemId,
                        driveId: item.driveId,
                        name: item.name,
                        mode,
                        downloadUrl: item.downloadUrl,
                        webUrl: item.webUrl,
                    };
                    const previousDisabled = new Map();
                    ingestModeButtons.forEach((btn) => {
                        previousDisabled.set(btn, btn.disabled);
                        if (!btn.disabled) {
                            btn.disabled = true;
                        }
                    });
                    setIngestModeHighlight(mode);
                    showIngestStatus(ingestAnalysisStatus, 'Generating metadata…', 'info');
                    try {
                        const res = await fetch('/api/ingest/process', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                        const responsePayload = await res.json().catch(() => ({}));
                        if (!res.ok) {
                            throw new Error(responsePayload.detail || 'Failed to generate metadata.');
                        }
                        const metadata = responsePayload.metadata || {};
                        const preview =
                            metadata.summary ||
                            metadata.title ||
                            (Object.keys(metadata).length ? JSON.stringify(metadata).slice(0, 160) : '');
                        const successMessage = preview ? `Metadata created: ${preview}` : 'Metadata request completed.';
                        showIngestStatus(ingestAnalysisStatus, successMessage, 'success');
                        await loadInbox();
                    } catch (error) {
                        showIngestStatus(ingestAnalysisStatus, error.message || 'Metadata request failed.', 'error');
                    } finally {
                        ingestModeButtons.forEach((btn) => {
                            const wasDisabled = previousDisabled.get(btn);
                            if (typeof wasDisabled === 'boolean') {
                                btn.disabled = wasDisabled;
                            }
                        });
                        setIngestModeHighlight(mode);
                    }
                }

                if (ingestModeButtons.length) {
                    ingestModeButtons.forEach((button) => {
                        button.addEventListener('click', () => {
                            if (button.disabled) {
                                return;
                            }
                            processIngestMode(button.dataset.mode);
                        });
                    });
                }

                resetIngestAnalysis();

                function attachDropHandlers(dropzone, input, onFileSelected) {
                    if (!dropzone || !input) {
                        return;
                    }
                    dropzone.addEventListener('dragover', (event) => {
                        event.preventDefault();
                        dropzone.classList.add('dragover');
                    });
                    dropzone.addEventListener('dragleave', () => {
                        dropzone.classList.remove('dragover');
                    });
                    dropzone.addEventListener('drop', (event) => {
                        event.preventDefault();
                        dropzone.classList.remove('dragover');
                        const file = event.dataTransfer.files[0];
                        if (file) {
                            onFileSelected(file);
                        }
                    });
                    dropzone.addEventListener('click', () => input.click());
                    input.addEventListener('change', () => {
                        const file = input.files[0];
                        if (file) {
                            onFileSelected(file);
                        }
                    });
                }

                function setRegularFile(file) {
                    resetIngestAnalysis();
                    if (!isPdfFile(file)) {
                        showIngestStatus(regularStatus, 'Please choose a PDF file.', 'error');
                        regularFile = null;
                        regularUpload.disabled = true;
                        if (regularLabel) regularLabel.textContent = regularDefaultLabel;
                        return;
                    }
                    regularFile = file;
                    if (regularLabel) regularLabel.textContent = file.name;
                    regularUpload.disabled = false;
                    if (regularInput) regularInput.value = '';
                    showIngestStatus(regularStatus, 'Ready to upload.', 'info');
                }

                function setOddFile(file) {
                    if (!isPdfFile(file)) {
                        showIngestStatus(massStatus, 'Odd pages must be a PDF file.', 'error');
                        oddFile = null;
                        if (oddLabel) oddLabel.textContent = oddDefaultLabel;
                        if (oddInput) oddInput.value = '';
                        updateMassReadyState();
                        return;
                    }
                    oddFile = file;
                    if (oddLabel) oddLabel.textContent = file.name;
                    if (oddInput) oddInput.value = '';
                    updateMassReadyState();
                }

                function setEvenFile(file) {
                    if (!isPdfFile(file)) {
                        showIngestStatus(massStatus, 'Even pages must be a PDF file.', 'error');
                        evenFile = null;
                        if (evenLabel) evenLabel.textContent = evenDefaultLabel;
                        if (evenInput) evenInput.value = '';
                        updateMassReadyState();
                        return;
                    }
                    evenFile = file;
                    if (evenLabel) evenLabel.textContent = file.name;
                    if (evenInput) evenInput.value = '';
                    updateMassReadyState();
                }

                function updateMassReadyState() {
                    const ready = Boolean(oddFile && evenFile);
                    massSubmit.disabled = !ready;
                    if (!ready) {
                        showIngestStatus(massStatus, 'Select both odd and even PDFs.', 'info');
                    } else {
                        showIngestStatus(massStatus, '', 'info');
                    }
                }

                attachDropHandlers(regularDrop, regularInput, setRegularFile);
                attachDropHandlers(oddDrop, oddInput, setOddFile);
                attachDropHandlers(evenDrop, evenInput, setEvenFile);

                if (regularUpload) {
                    regularUpload.addEventListener('click', async () => {
                        if (!regularFile) {
                            return;
                        }
                        regularUpload.disabled = true;
                        showIngestStatus(regularStatus, 'Uploading…', 'info');
                        const formData = new FormData();
                        formData.append('file', regularFile, regularFile.name);
                        try {
                            const res = await fetch('/api/ingest/upload', { method: 'POST', body: formData });
                            const payload = await res.json().catch(() => ({}));
                            if (!res.ok) {
                                throw new Error(payload.detail || 'Failed to upload PDF');
                            }
                            showIngestStatus(regularStatus, `Uploaded ${payload.filename}`, 'success');
                            if (payload.analysis) {
                                renderIngestAnalysis({
                                    analysis: payload.analysis,
                                    item: payload.item || {},
                                    recommendedStrategy: payload.recommendedStrategy,
                                });
                            } else {
                                renderIngestAnalysis(null);
                            }
                            regularFile = null;
                            regularUpload.disabled = true;
                            if (regularLabel) regularLabel.textContent = regularDefaultLabel;
                            await loadInbox();
                        } catch (error) {
                            showIngestStatus(regularStatus, error.message || 'Upload failed.', 'error');
                            regularUpload.disabled = false;
                        }
                    });
                }

                if (massForm && massSubmit) {
                    massSubmit.disabled = true;
                    massForm.addEventListener('submit', async (event) => {
                        event.preventDefault();
                        if (!oddFile || !evenFile) {
                            showIngestStatus(massStatus, 'Select both odd and even PDFs before uploading.', 'error');
                            updateMassReadyState();
                            return;
                        }
                        massSubmit.disabled = true;
                        showIngestStatus(massStatus, 'Combining and uploading…', 'info');
                        const formData = new FormData();
                        formData.append('oddFile', oddFile, oddFile.name);
                        formData.append('evenFile', evenFile, evenFile.name);
                        if (outputNameInput && outputNameInput.value.trim()) {
                            formData.append('outputName', outputNameInput.value.trim());
                        }
                        try {
                            const res = await fetch('/api/ingest/mass-scan', { method: 'POST', body: formData });
                            const payload = await res.json().catch(() => ({}));
                            if (!res.ok) {
                                throw new Error(payload.detail || 'Failed to upload merged PDF');
                            }
                            showIngestStatus(massStatus, `Uploaded ${payload.filename} (${payload.pages} pages)`, 'success');
                            oddFile = null;
                            evenFile = null;
                            if (oddLabel) oddLabel.textContent = oddDefaultLabel;
                            if (evenLabel) evenLabel.textContent = evenDefaultLabel;
                            if (oddInput) oddInput.value = '';
                            if (evenInput) evenInput.value = '';
                            if (outputNameInput) outputNameInput.value = '';
                            await loadInbox();
                        } catch (error) {
                            showIngestStatus(massStatus, error.message || 'Upload failed.', 'error');
                        } finally {
                            updateMassReadyState();
                        }
                    });
                }

                function startProcessingIndicators(ids) {
                    ids.forEach((id) => {
                        if (!state.processingQueue.includes(id) && state.activeProcessingId !== id) {
                            const item = state.inboxItems.find((entry) => entry.id === id);
                            if (!item) {
                                return;
                            }
                            if (item.status === 'success') {
                                return;
                            }
                            if (item.status === 'failed') {
                                item.status = 'pending';
                                item.error_message = null;
                            }
                            state.processingQueue.push(id);
                            item.transient_note = 'Queued for processing';
                            state.selectedInboxIds.add(id);
                        }
                    });
                    renderInboxTable();
                    startProcessingLoop();
                }

                function stopProcessingIndicator(id) {
                    const entry = state.processingTimers.get(id);
                    if (entry) {
                        clearInterval(entry.timer);
                        state.processingTimers.delete(id);
                    }
                }

                function startProcessingLoop() {
                    if (state.activeProcessingId) {
                        renderInboxTable();
                        return;
                    }
                    while (state.processingQueue.length) {
                        const nextId = state.processingQueue.shift();
                        const item = state.inboxItems.find((entry) => entry.id === nextId);
                        if (!item || item.status === 'success' || item.status === 'failed') {
                            continue;
                        }
                        state.activeProcessingId = nextId;
                        item.status = 'processing';
                        item.error_message = null;
                        let stageIndex = 0;
                        const stageKeys = state.progressOrder;

                        const updateNote = () => {
                            const key = stageKeys[Math.min(stageIndex, stageKeys.length - 1)];
                            const label = state.progressLabels[key] || key;
                            item.transient_note = `Processing: ${label}`;
                            renderInboxTable();
                            if (stageIndex < stageKeys.length - 1) {
                                stageIndex += 1;
                            }
                        };

                        updateNote();
                        const timer = setInterval(updateNote, 2000);
                        state.processingTimers.set(nextId, { timer });
                        renderInboxTable();
                        return;
                    }
                    renderInboxTable();
                }

                function updateProcessingResult(result) {
                    stopProcessingIndicator(result.id);
                    const item = state.inboxItems.find((entry) => entry.id === result.id);
                    if (!item) {
                        return;
                    }
                    state.selectedInboxIds.delete(result.id);
                    const progress = Array.isArray(result.progress) ? result.progress : [];
                    const progressText = progress
                        .map((stage) => state.progressLabels[stage] || stage)
                        .filter(Boolean)
                        .join(' → ');
                    if (result.status === 'success') {
                        item.status = 'success';
                        item.error_message = null;
                        item.metadata_preview = item.metadata_preview || '';
                        item.transient_note = progressText ? `Completed: ${progressText}` : 'Completed.';
                    } else if (result.status === 'failed') {
                        item.status = 'failed';
                        item.error_message = result.error || 'Processing failed.';
                        item.transient_note = progressText ? `Aborted after: ${progressText}` : (item.error_message || 'Processing failed.');
                    } else if (result.status === 'missing') {
                        item.status = 'pending';
                        item.transient_note = 'Item missing from inbox.';
                    }
                    if (state.activeProcessingId === result.id) {
                        state.activeProcessingId = null;
                    }
                    state.processingQueue = state.processingQueue.filter((id) => id !== result.id);
                    startProcessingLoop();
                }

                async function init() {
                    try {
                        await fetchConfig();
                        populateConfigForms();
                    } catch (error) {
                        console.error(error);
                    }
                    await loadInbox();
                    await loadStructureSources();
                    await loadStructureState();
                    setStructurePolling(DEFAULT_STRUCTURE_POLL_MS);
                }

                init().catch((error) => {
                    console.error('Initialization failed:', error);
                });
            });
        </script>
    </body>
</html>
